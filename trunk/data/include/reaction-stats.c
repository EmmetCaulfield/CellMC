#include <stdlib.h>	/* For qsort() */
#include <stdio.h>

#include "reaction-stats.h"
#include "types.h"
#include "error-macros.h"


/**
 * Compares reaction statistics for sorting in descending order:
 */
static int _rs_cmp(const void *a, const void *b) {
    const reaction_stats_t *ra=(reaction_stats_t *)a;
    const reaction_stats_t *rb=(reaction_stats_t *)b;

    if( ra->n_rxns > rb->n_rxns )
	return -1;
    if( ra->n_rxns < rb->n_rxns )
	return 1;
    return 0;
}


/**
 * Sorts an array of reaction_stats_t in descending order by n_rxns
 */
static uint64_t _rs_sort(reaction_stats_t *rs)
{
    uint64_t rsum=0LL;
    int i;
    
    /*
     * Use
     */
    qsort(rs, N_RXNS, sizeof(reaction_stats_t), _rs_cmp);

    // Sum propensities:
    for(i=0; i<N_RXNS; i++) {
	rsum += rs[i].n_rxns;
    }

    for(i=0; i<N_RXNS; i++) {
	rs[i].percent = 100.0*(double)rs[i].n_rxns/(double)rsum;
    }

    return rsum;
}



/**
 * Prints XSL-T preamble -- including XML declaration, copy templates,
 * etc. -- for reordering reactions in XML model. Output is to file
 * 'fp'.  Unless suppressed, si_header() info is inserted as unparsed
 * CDATA (to avoid "--" in the info terminating a comment) and
 * si->app.lbl is inserted into the "k:via" position to record the
 * provenance of the XSL-T.
 */
static void _rs_fprint_xslt_header(sim_info_t *si, FILE *fp) {
    DIE_IF(fp==NULL, "File pointer 'fp' cannot be NULL");

    fputs( 
"<?xml version='1.0'?>\n"
"<xsl:transform\n"
"  xmlns:s='http://www.sbml.org/sbml/level2/version3'\n"
"  xmlns:xsl='http://www.w3.org/1999/XSL/Transform'\n"
"  xmlns:m='http://www.w3.org/1998/Math/MathML'\n"
"  xmlns:k='http://polacksbacken.net/wiki/SSACBE'\n"
"  version='1.0'>\n"
"  <k:comment>\n", fp);

    if( si->header ) {
	fputs("<![CDATA[\n", fp);
	si_header(si, fp, "# ", "");
	fputs("]]>\n", fp);
    }

    fputs(
"  </k:comment>\n"
"  <xsl:output\n"
"    method='xml'\n"
"    media-type='text/xml'\n"
"    indent='yes'\n"
"    encoding='utf-8'/>\n"
"\n"
"  <xsl:strip-space elements='*'/>\n"
"\n"
"  <xsl:template match='k:provenance'>\n"
"    <k:provenance>\n"
"      <xsl:apply-templates/>\n"
"      <k:via>", fp);

    fputs(si->app.lbl,fp);

    fputs("</k:via>\n"
"    </k:provenance>\n"
"  </xsl:template>\n"
"\n"
"  <xsl:template match='@*|node()'>\n"
"    <xsl:copy>\n"
"      <xsl:apply-templates select='@*|node()'/>\n"
"    </xsl:copy>\n"
"  </xsl:template>\n"
"\n"
"  <xsl:template match='s:listOfReactions'>\n"
"    <s:listOfReactions>\n", fp);
}


/**
 * Prints XSL-T footer for reordering reactions in XML model
 */
static void _rs_fprint_xslt_footer(FILE *fp) {
    DIE_IF(fp==NULL, "Stream pointer must not be NULL");

    fprintf(fp, 
"    </s:listOfReactions>\n"
"  </xsl:template>\n"
"</xsl:transform>\n"
	);

}


/**
 * Prints XSL-T for reordering reactions in an SBML model given
 * reaction statistics in the form of an array of reaction_stats_t
 * generated by rs_init().
 */
void rs_print_sro_xslt(sim_info_t *si, FILE *fp)
{
    int i;
    reaction_stats_t *rs = (reaction_stats_t *)si->helper_data; 
    
    DIE_IF(rs==NULL, "Helper data (reaction_stats) is NULL");
    DIE_IF(fp==NULL, "FILE pointer must not be NULL");

    _rs_fprint_xslt_header(si, fp);
    for(i=0; i<N_RXNS; i++) {
	fprintf(fp, "      <!-- # "T_PIS_FMT"/%"PRIu64", %.2f%% -->\n", rs[i].n_rxns, si->abs_rxn_total, rs[i].percent);
	fprintf(fp, "      <xsl:apply-templates select=\"s:reaction[%d]\"/>\n", rs[i].orig_posn);
    }
    _rs_fprint_xslt_footer(fp);
}


/**
 * Initialises reaction statistics structures within 'si', and sorts
 * them in descending order by number of reactions.
 */
void rs_init(sim_info_t *si)
{
    reaction_stats_t *rs;
    T_PIS *rcnts;
    uint64_t rxn_ttl;
    int i;

    /*
     * This shouldn't happen:
     */
    if( si->helper_data != NULL ) {
	WARN("Helper data pointer seems to be in use - cleaning up");
	DIE_IF(si->helper_cleanup_fn == NULL, "No helper cleanup function");
	si->helper_cleanup_fn(si);
    }

    rcnts = (T_PIS *)si->results;
    DIE_IF(rcnts==NULL, "No results in sim_info_t struct");

    rs=(reaction_stats_t *)calloc(N_RXNS,sizeof(reaction_stats_t));
    RCHECK(rs, !=NULL, calloc);
    si->helper_data = (void *)rs;
    si->helper_cleanup_fn = _rs_cleanup;

    for(i=0; i<N_RXNS; i++) {
	rs[i].n_rxns    = rcnts[i];
	rs[i].orig_posn = i+1;
    }

    rxn_ttl = _rs_sort(rs);
    WARN_IF(si->abs_rxn_total!=rxn_ttl, "Reaction counts don't match as expected");
}


/**
 * Frees data allocated in rs_init() and sets si->helper_data and
 * si->helper_cleanup_fn to NULL.
 */
void _rs_cleanup(sim_info_t *si) {
    DIE_IF(si==NULL, "Passed NULL - cleanup failed.");
    free( si->helper_data );
    si->helper_data = NULL;
    si->helper_cleanup_fn = NULL;
}
